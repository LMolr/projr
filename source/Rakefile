require 'fileutils'
require 'pathname'
require 'ostruct'
require 'highline/import'

require 'erubis'
require 'haml'
require 'liquid'
require 'redcloth'
require 'rdoc'
require 'rdoc/markup'
require 'rdoc/markup/to_html'
require 'rdiscount'
require 'sass'
require 'less'
require 'coffee_script'
require 'tilt'
require 'awesome_print'


MARKUP_NAME = 'markup'
SCRIPTS_NAME = 'scripts'
STYLES_NAME = 'styles'
IMAGES_NAME = 'images'
CONFIG_NAME = 'config.yml'

ROOT_PTH = Pathname.new File.dirname(__FILE__)
MARKUP_PTH = ROOT_PTH.join(MARKUP_NAME)
SCRIPTS_PTH = ROOT_PTH.join(SCRIPTS_NAME)
STYLES_PTH = ROOT_PTH.join(STYLES_NAME)
IMAGES_PTH = ROOT_PTH.join(IMAGES_NAME)
OUT_PTH = ROOT_PTH.dirname


# { Support methods & classes / Helper methods

def symbolize(obj)
  return obj.inject({}) { |memo, (k,v)| memo[k.to_sym] = symbolize(v); memo } if obj.is_a? Hash
  return obj.inject([]) { |memo, v| memo << symbolize(v); memo } if obj.is_a? Array
  obj
end

def load_config
  begin
    config = YAML::load(File.open(ROOT_PTH.join(CONFIG_NAME), 'r'))
    config.merge!({
      :markup_name => MARKUP_NAME,
      :scripts_name => SCRIPTS_NAME,
      :styles_name => STYLES_NAME,
      :images_name => IMAGES_NAME,
      :root_pth => ROOT_PTH,
      :markup_pth => MARKUP_PTH,
      :scripts_pth => SCRIPTS_PTH,
      :styles_pth => STYLES_PTH,
      :images_pth => IMAGES_PTH
    })
    symbolize(config)
  rescue
    nil
  end
end

def get_from_templ(pth, config)
  begin
    Tilt.new(pth.to_s).render(self, :v => config)
  rescue Exception => exc
    raise "Error while getting content from template #{pth}\n"\
        "\tReason: #{exc.message}\n\t#{exc.backtrace.join("\n\t")}"
  end
end

def compile_files
  config = load_config
  if config.nil?
    puts "Cannot load the configuration file: #{CONFIG_NAME}"
    puts 'Compiling aborted'
    return false
  end

  compile_data = [
    { :regex => /^.+(\.(?:erb|rhtml|erubis|haml|liquid|markdown|mkd|md|textile|rdoc))$/,
      :out_ext => lambda { |ext| '.html' },
      :behaviour => lambda { |md, fp| Tilt.new(fp).render(self, :v => config) }
    },
    { :regex => /^.+(\.(?:html|xhtml|htm|xml))$/,
      :out_ext => lambda { |ext| '.html' },
      :behaviour => lambda { |md, fp| File.open(fp, 'r') { |f| f.read } }
    },
    { :regex => /^.+(\.(?:sass|scss))$/,
      :out_ext => lambda { |ext| '.css' },
      :behaviour => lambda { |md, fp|
        Dir.chdir(STYLES_PTH) do
          Sass::Engine.new(File.open(fp, 'r') { |f| f.read }).render
        end
      }
    },
    { :regex => /^.+(\.less)$/,
      :out_ext => lambda { |ext| '.css' },
      :behaviour => lambda { |md, fp|
        Dir.chdir(STYLES_PTH) do
          Less::Parser.new.parse(File.open(fp, 'r') { |f| f.read }).to_css
        end
      }
    },
    { :regex => /^.+(\.css)$/,
      :out_ext => lambda { |ext| '.css' },
      :behaviour => lambda { |md, fp| File.open(fp, 'r') { |f| f.read } }
    },
    { :regex => /^.+(\.(?:coffee|coffeescript))$/,
      :out_ext => lambda { |ext| '.js' },
      :behaviour => lambda { |md, fp|
        CoffeeScript.compile(File.open(fp, 'r') { |f| f.read })
      }
    },
    { :regex => /^.+(\.(?:js|javascript))$/,
      :out_ext => lambda { |ext| '.js' },
      :behaviour => lambda { |md, fp| File.open(fp, 'r') { |f| f.read } }
    },
    { :regex => /^.+(\.(?:png|svg|jpeg|jpg|gif|eot|ttf|woff))$/,
      :out_ext => lambda { |ext| ext },
      :behaviour => lambda { |md, fp| File.open(fp, 'r') { |f| f.read } }
    }
  ]

  Dir[ROOT_PTH.join('**', '*')].each do |file_pth|
    out_file_pth = file_pth.sub(/^#{ROOT_PTH}/, OUT_PTH.to_s)

    found = false
    compile_data.each do |e|
      if (md = e[:regex].match(out_file_pth)) && !found
        found = true
        out_file_pth.sub!(md[1], e[:out_ext].call(md[1]))
        puts "Compiling #{file_pth} into #{out_file_pth}"
        FileUtils.makedirs(File.dirname(out_file_pth))
        out_file_cntn = e[:behaviour].call(md, file_pth)
        unless out_file_cntn.nil?
          File.open(out_file_pth, 'w') { |out_f| out_f.write(out_file_cntn) }
        end
      end
    end
  end
end

# }

# { Tasks

desc 'Preview the website'
task :preview => [:cleanup, :compile] do
  system "xdg-open #{OUT_PTH.join('index.html')}"
end

desc 'Compile the sources'
task :compile do
  status = compile_files
  puts "#{status ? 'Successfully compiled' : 'Failed to compile'} the sources"
end

desc 'Cleanup the compiled website'
task :cleanup do
  compiled_files_pths = Dir[OUT_PTH.join('**')].delete_if do |file_pth|
    file_pth =~ /LICENSE\.md|README\.md|#{ROOT_PTH}/
  end
  unless compiled_files_pths.empty?
    if agree("Remove these files?\n[ #{compiled_files_pths.join(', ')} ]")
      compiled_files_pths.each { |file_pth| FileUtils.rm_r(file_pth) }
    end
  end
end

# }
