require 'fileutils'
require 'pathname'
require 'ostruct'
require 'highline/import'

require 'erubis'
require 'haml'
require 'liquid'
require 'redcloth'
require 'rdoc'
require 'rdoc/markup'
require 'rdoc/markup/to_html'
require 'rdiscount'
require 'sass'
require 'less'
require 'coffee_script'
require 'tilt'
require 'awesome_print'
require 'rest_client'
require 'erector'
Erector::Widget.prettyprint_default = true


HELPERS_NAME = 'helpers'
MARKUP_NAME = 'markup'
PARTIALS_NAME = 'partials'
LAYOUTS_NAME = 'layouts'
SCRIPTS_NAME = 'scripts'
STYLES_NAME = 'styles'
IMAGES_NAME = 'images'
CONFIG_NAME = 'config.yml'

ROOT_PTH = Pathname.new File.dirname(__FILE__)
OUT_PTH = ROOT_PTH.dirname
HELPERS_PTH = ROOT_PTH.join(HELPERS_NAME)
MARKUP_PTH = ROOT_PTH.join(MARKUP_NAME)
PARTIALS_PTH = MARKUP_PTH.join(PARTIALS_NAME)
LAYOUTS_PTH = MARKUP_PTH.join(LAYOUTS_NAME)
SCRIPTS_PTH = ROOT_PTH.join(SCRIPTS_NAME)
STYLES_PTH = ROOT_PTH.join(STYLES_NAME)
IMAGES_PTH = ROOT_PTH.join(IMAGES_NAME)

# Load the helpers
Dir.glob(HELPERS_PTH.join('**', '*.rb')) { |fp| require fp }


# { Support methods & classes / Helper methods

def symbolize(obj)
  return obj.inject({}) { |memo, (k,v)| memo[k.to_sym] = symbolize(v); memo } if obj.is_a? Hash
  return obj.inject([]) { |memo, v| memo << symbolize(v); memo } if obj.is_a? Array
  obj
end

def load_config
  begin
    config = YAML::load(File.open(ROOT_PTH.join(CONFIG_NAME), 'r'))
    config.merge!({
      :markup_name => MARKUP_NAME,
      :partials_name => PARTIALS_NAME,
      :layouts_name => LAYOUTS_NAME,
      :scripts_name => SCRIPTS_NAME,
      :styles_name => STYLES_NAME,
      :images_name => IMAGES_NAME,
      :root_pth => ROOT_PTH,
      :markup_pth => MARKUP_PTH,
      :partials_pth => PARTIALS_PTH,
      :layouts_pth => LAYOUTS_PTH,
      :scripts_pth => SCRIPTS_PTH,
      :styles_pth => STYLES_PTH,
      :images_pth => IMAGES_PTH
    })
    symbolize(config)
  rescue
    nil
  end
end

def compile_files
  config = load_config
  if config.nil?
    puts "Cannot load the configuration file: #{CONFIG_NAME}"
    puts 'Compiling aborted'
    return false
  end

  compile_data = [
    { :regex => /^.+(\.(?:erb|rhtml|erubis|haml|liquid|markdown|mkd|md|textile))$/,
      :out_ext => lambda { |ext| '.html' },
      :behaviour => lambda { |md, fp|
        # find comment tags
        oc, cc = if /\.haml/.match(md[1]); %w(# )
        elsif /\.liquid/.match(md[1]); %w({% %})
        elsif /\.textile/.match(md[1]); %w(==<!-- -->==)
        else %w(<!-- -->)
        end

        if /^#{PARTIALS_PTH}\/.+$/.match(fp) || /^#{LAYOUTS_PTH}\/.+$/.match(fp)
          nil # skip the layouts and partials generation
        else
          line = File.open(fp, 'r') { |f| f.readline } rescue ''
          layout_md = /^#{oc}\s*layout\s*:\s*(\S*)\s*#{cc}$/i.match(line.strip)
          if layout_md.nil?
            Tilt.new(fp).render(self, :v => config)
          else
            layout_pth = File.join(LAYOUTS_PTH, layout_md[1])
            if File.exist?(layout_pth)
              out_lines = File.open(fp, 'r') { |f| f.readlines }
              out_lines.delete_at(0)
              tmp_file = Tempfile.new(['template', md[1]])
              tmp_file.write(out_lines.join(''))
              tmp_file_pth = tmp_file.path
              tmp_file.close
              out_cntn = Tilt.new(layout_pth).render(self, :v => config) {
                Tilt.new(tmp_file_pth).render(self, :v => config)
              }
              tmp_file.unlink
              out_cntn # return
            else
              Tilt.new(fp).render(self, :v => config)
            end
          end
        end
      }
    },
    { :regex => /^.+(\.(?:html|xhtml|htm|xml))$/,
      :out_ext => lambda { |ext| '.html' },
      :behaviour => lambda { |md, fp| File.open(fp, 'r') { |f| f.read } }
    },
    { :regex => /^.+(\.(?:sass|scss))$/,
      :out_ext => lambda { |ext| '.css' },
      :behaviour => lambda { |md, fp|
        Dir.chdir(STYLES_PTH) do
          Sass::Engine.new(File.open(fp, 'r') { |f| f.read }).render
        end
      }
    },
    { :regex => /^.+(\.less)$/,
      :out_ext => lambda { |ext| '.css' },
      :behaviour => lambda { |md, fp|
        Dir.chdir(STYLES_PTH) do
          Less::Parser.new.parse(File.open(fp, 'r') { |f| f.read }).to_css
        end
      }
    },
    { :regex => /^.+(\.css)$/,
      :out_ext => lambda { |ext| '.css' },
      :behaviour => lambda { |md, fp| File.open(fp, 'r') { |f| f.read } }
    },
    { :regex => /^.+(\.(?:coffee|coffeescript))$/,
      :out_ext => lambda { |ext| '.js' },
      :behaviour => lambda { |md, fp|
        CoffeeScript.compile(File.open(fp, 'r') { |f| f.read })
      }
    },
    { :regex => /^.+(\.(?:js|javascript))$/,
      :out_ext => lambda { |ext| '.js' },
      :behaviour => lambda { |md, fp| File.open(fp, 'r') { |f| f.read } }
    },
    { :regex => /^.+(\.(?:png|svg|jpeg|jpg|gif|eot|ttf|woff))$/,
      :out_ext => lambda { |ext| ext },
      :behaviour => lambda { |md, fp| File.open(fp, 'r') { |f| f.read } }
    }
  ]

  Dir[ROOT_PTH.join('**', '*')].each do |file_pth|
    out_file_pth = file_pth.sub(/^#{ROOT_PTH}/, OUT_PTH.to_s)

    found = false
    compile_data.each do |e|
      if (md = e[:regex].match(out_file_pth)) && !found
        found = true
        out_file_pth.sub!(md[1], e[:out_ext].call(md[1]))

        # for files under markup/pages compile them in the output root dir
        if (md2 = /^(#{OUT_PTH})\/#{MARKUP_NAME}\/pages\/(.+)$/.match(out_file_pth))
          out_file_pth = File.join(md2[1], md2[2])
        end

        unless
          puts "Compiling #{file_pth} into #{out_file_pth}"
          FileUtils.makedirs(File.dirname(out_file_pth))
          out_file_cntn = e[:behaviour].call(md, file_pth)
          unless out_file_cntn.nil?
            File.open(out_file_pth, 'w') { |out_f| out_f.write(out_file_cntn) }
          end
        end
      end
    end
  end
end

# }

# { Tasks

desc 'Preview the website'
task :preview => :compile do
  system "xdg-open #{OUT_PTH.join('index.html')}"
end

desc 'Compile the sources'
task :compile => :cleanup do
  status = compile_files
  puts "#{status ? 'Successfully compiled' : 'Failed to compile'} the sources"
end

desc 'Cleanup the compiled website'
task :cleanup do
  compiled_files_pths = Dir[OUT_PTH.join('**')].delete_if do |file_pth|
    file_pth =~ /LICENSE\.md|README\.md|#{ROOT_PTH}/
  end
  unless compiled_files_pths.empty?
    if agree("Remove these files?\n[ #{compiled_files_pths.join(', ')} ]")
      compiled_files_pths.each { |file_pth| FileUtils.rm_r(file_pth) }
    end
  end
end

# }
#
